---
layout: post
title: (알고리즘 문제) 게임판 덮기 - 난이도(하)
---

H x W 크기의 게임판이 있습니다. 게임판은 검은 칸과 흰 칸으로 구성된 격자 모양을 하고 있는데 이 중 모든 흰 칸을 세 칸짜리 L자 모양의 블록으로 덮고 싶습니다. 이때 블록들은 자유롭게 회전해서 놓을 수 있지만, 서로 겹치거나, 검은 칸을 덮거나, 게임판 밖으로 나가서는 안 됩니다.

게임판이 주어질 때 이를 덮는 방법의 수를 계산하는 프로그램을 작성하세요.

#### 입력
첫 줄에는 테스트 케이스의 수 C(C<=30)가 주어집니다. 각 테스트 케이스의 첫 줄에는 두 개의 정수 H, W(1<=H, W<=20)가 주어집니다. 다음 H 줄에 각 W 글자로 게임판의 모양이 주어집니다. #은 검은칸, .는 흰 칸을 나타냅니다. 입력에 주어지는 흰 칸의 수는 50을 넘지 않습니다.

#### 출력
한 줄에 하나씩 흰 칸을 모두 덮는 방법의 수를 출력합니다.

#### 예제 입력
```
3
3 7
#.....#
#.....#
##...##
3 7
#.....#
#.....#
##..###
8 10
##########
#........#
#........#
#........#
#........#
#........#
#........#
##########
```

#### 예제 출력
```
0
2
1514
```

### 풀이 - 언어: javascript
지난 문제보다는 막막함이 덜 했던 것 같다. 블록의 회전형태는 4가지 형태가 존재하므로 회전형태에 따른 상대 좌표값을 상수로 저장해놓고 처리해야 겠다는 생각이 들었다. 이전에 책을 읽으면서 풀이를 읽었던 문제라 왼쪽 위 흰 칸 부터 차례대로 메꿔나가는 경우의 수를 세면 된다는 걸 미리 알고 있었다.

책의 풀이 코드를 보지 않고 풀어 본 다음 책의 코드와 비교해봤을때 배울만한 점이 꽤 있었다. setCover 함수에서의 delta 값을 이용해서 덮힌 블록 처리를 설정/해제 하는 기법은 신선했다.

내가 짠 코드에서는 검은 블럭은 -1, 흰 블럭은 0, 블록으로 덮힌곳은 1로 배열에 저장했는데, 책의 풀이는 흰 블럭은 0, 검은색이나 이미 덮힌 블럭은 1로 표현했다. 나는 별 생각없이 검은 블럭과 블록으로 덮힌 부분은 구분이 되어야 한다고 생각했었는데 돌이켜보면 굳이 그럴 필요가 없었다. 검은 블럭이면 수를 더하거나 빼지 말아야하기 때문에 구별해야 한다고 생각했는데 풀이의 setCover 메서드는 이 문제를 심플하게 풀어냈다.

내가 짠 코드는 계산 효율성을 위해서 coverCase 함수에서 파라메터를 더 받는 차이가 있었다. 성능은 조금더 좋을 것 같은데 코드가 좀 지저분하다. 문제의 제한 사항이 그리 크지 않으므로 그냥 심플하게 짜는게 좋을 뻔했다.

#### 배운 점들
- 재귀 호출의 기저 사례(base case)
- 재귀호출에서 '문제'란 항상 수행해야할 작업과 그 작업을 적용할 자료의 조합을 말한다.
- Array pop, push 메서드. String charAt, substring 메서드.
- 책에서 왜 항상 y, x 순으로 좌표를 받았는지 이제 좀 이해할 것 같다. 입력 파일을 읽어올때 y 좌표로 먼저 접근한다.
- 코드상에서의 좌표는 상하 반전으로 생각하고 작성해야 편하다. 아래쪽이 y좌표 + 방향.

---
layout: post
title: (알고리즘 문제) 시계 맞추기 - 난이도(중)
---

4x4개의 격자 형태로 배치된 열여섯 개의 시계가 있습니다. 이 시계들은 모두 12시, 3시, 6시, 9시를 가리키고 있는데, 이 시계들이 모두 12시를 가리키도록 바꾸고 싶습니다.

시계의 시간을 조작하는 유일은 방법은 열 개의 스위치들을 조작하는 것으로, 각 스위치들은 모두 적게는 세 개에서 많게는 다섯 개의 시계에 연결되어 있습니다. 한 스위치를 누를 때마다, 해당 스위치와 연결된 시계들의 시간은 3시간씩 앞으로 움직입니다.

시계들이 현재 가리키는 시간들이 주어졌을 때 모든 시계를 12시로 돌리기 위해 최소한 스위치를 몇 번이나 눌러야 할지 계산하는 프로그램을 작성하세요.

#### 입력
첫 줄에 테스트 케이스의 개수(C<=30)가 주어집니다. 각 테스트 케이스는 한 줄에 16개의 정수로 주어지며, 각 정수는 각 시계가 가리키고 있는 시간을 12, 3, 6, 9 중 하나로 표현합니다.

#### 출력
시계들을 모두 12시로 돌려놓기 위해 스위치를 눌러야 할 최소 횟수여야 하며, 만약 이것이 불가능할 경우 -1을 출력해야 합니다.

#### 예제 입력
```
2
12 6 6 6 6 6 12 12 12 12 12 12 12 12 12 12
12 9 3 12 6 6 9 3 12 9 12 9 12 12 6 6
```

#### 예제 출력
```
2
9
```

### 풀이 - 언어: javascript
처음 문제를 읽었을때는 단순히 모든 시계가 12시가 될때까지 스위치 정보 배열을 반복시키면 되지 않을까? 라고 생각했었다. 물론 그렇게 쉽게 풀리는 문제였으면 난이도 **중** 문제가 아니였겠지. 내 단순한 생각은 실제 코드로 짜서 돌렸을때 무한 루프를 만들어냈다. 이 무한루프를 어떻게 끝나게 만들어 낼 수 있을까를 고민해 봤지만 쉽게 해결책이 떠오르지 않았다. 결국 풀이 행...

이 문제를 풀기 위한 핵심은 두 가지가 있다. 이 두 가지 아이디어를 떠올리지 못한다면 결국 문제를 풀지 못했을 것이다.

- 문제에서 요구하는 것은 **최소** 횟수이다. 모든 시계를 12시로 맞추는 어떤 최소 시도 방법이 있을때, 해당 방법 내에서 스위치를 누르는 순서는 중요하지 않을것이다.
- 스위치를 누를때마다 3시간씩 앞으로 가므로 모든 스위치는 4번을 누르게되면 시계의 상태가 본래대로 돌아오므로 4번 이상 누르는 것은 의미가 없다.

#### 배운 점들
- 문제를 잘! 읽어봐야 한다.
- _allocClock() 내의 재귀 호출 법.

#### 풀이 코드
```javascript
'use strict';

const SWITCHS = 10;
const CLOCKS = 16;
const INF = 99999;
const swtch = [
    [0,1,2],
    [3,7,9,11],
    [4,10,14,15],
    [0,4,5,6,7],
    [6,7,8,10,12],
    [0,2,14,15],
    [3,14,15],
    [4,5,7,14,15],
    [1,2,3,4,5],
    [3,4,5,9,13]
];

let clock = [12,6,6,6,6,6,12,12,12,12,12,12,12,12,12,12]; // 길이 16의 시계 시간 정보
let result = _allocClock(0);
if (result === INF) {
    console.log(-1);
} else {
    console.log(result);
}

clock = [12,9,3,12,6,6,9,3,12,9,12,9,12,12,6,6]; // 길이 16의 시계 시간 정보
result = _allocClock(0);
if (result === INF) {
    console.log(-1);
} else {
    console.log(result);
}

function _allocClock(switchNum) {
    if (switchNum === SWITCHS) {
        return _isAlloc();
    }

    let ret = INF;

    for (let i = 0; i < 4; ++i) {
        ret = Math.min(ret, i + _allocClock(switchNum+1));
        _push(swtch[switchNum]);
    }

    return ret;
}

function _isAlloc() {
    let done = 0;

    for (let time of clock) {
        if (time !== 12) {
            done = INF;
            break;
        }
    }

    return done;
}

function _push(indexes) {
    for (let i of indexes) {
        clock[i] += 3;

        if (clock[i] === 15) {
            clock[i] = 3;
        }
    }
}
```